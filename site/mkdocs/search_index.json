{
    "docs": [
        {
            "location": "/", 
            "text": "Dapple\n\n\ndapple\n helps Solidity developers build and manage complex contract systems on Ethereum blockchains.\n\n\nSome features:\n\n\n\n\nContracts are run through the \ncog\n preprocessor, which has a few use cases:\n\n\n\"generic\" functions\n\n\nSingleton contracts (hard-code addresses for a particular chain context)\n\n\n\n\n\n\nA plugin system that allows developers to override almost any aspect of Dapple's behavior.\n\n\ndapple test\n: You write your Solidity tests in Solidity, not Javascript!\n\n\ndapple build\n: Compile your smart contract package and display the output as JSON.\n\n\ndapple install\n: Install smart contract packages from a global smart package repository on IPFS.\n\n\ndapple publish\n: Publish your smart contract package to IPFS for others to use.\n\n\ndapple do\n reproducible deploy steps\n\n\npackage system (a \npack\n is solidity sources + chain contexts + some metadata)\n\n\n\n\nFuture plans:\n\n\n\n\nWork towards a contract package standard\n\n\nadmin GUI based on universal-dapp\n\n\n\n\nSource code can be found up on \nGithub\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#dapple", 
            "text": "dapple  helps Solidity developers build and manage complex contract systems on Ethereum blockchains.  Some features:   Contracts are run through the  cog  preprocessor, which has a few use cases:  \"generic\" functions  Singleton contracts (hard-code addresses for a particular chain context)    A plugin system that allows developers to override almost any aspect of Dapple's behavior.  dapple test : You write your Solidity tests in Solidity, not Javascript!  dapple build : Compile your smart contract package and display the output as JSON.  dapple install : Install smart contract packages from a global smart package repository on IPFS.  dapple publish : Publish your smart contract package to IPFS for others to use.  dapple do  reproducible deploy steps  package system (a  pack  is solidity sources + chain contexts + some metadata)   Future plans:   Work towards a contract package standard  admin GUI based on universal-dapp   Source code can be found up on  Github .", 
            "title": "Dapple"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quickstart\n\n\nA note before starting\n\n\nThroughout this documentation, I use words in \n to denote where you should fill in values of your own choosing. I have endeavored to make the angle-bracketed phrases self-explanatory and consistent. For example, I use \n to denote the name you choose for your package. Anywhere you see \n, you should be able to fill in the same value you chose initially and do alright.\n\n\nInstallation\n\n\nOn the command line:\n\n\ngit clone https://github.com/MakerDAO/dapple\ncd dapple\npython setup.py install\n\n\n\nPackage creation\n\n\nOn the command line:\n\n\nmkdir \nmypackage\n\ncd \nmypackage\n\ndapple init\n\n\n\nDapple packages are defined by the presence of a \n.dapple\n directory containing a \ndappfile\n YAML file. \ndapple init\n creates this structure for you. Edit \n.dapple/dappfile\n in your \n directory to, at minimum, list your package's name and version. By default, the \ncore\n package is included as a dependency of all new packages. The \ncore\n package contains the contracts that Dapple relies on to run tests on your smart contract package.\n\n\nPackage installation\n\n\nFrom within your package's root directory:\n\n\ndapple install \nsomepackage\n --save\n\n\n\nThe \n--save\n flag tells Dapple that it should add the package to your dependencies map in your dappfile. Without this flag, Dapple would install the package without adding it to your dappfile. Generally, Dapple tries to make it obvious when it's about to change your dappfile. Running \ninstall\n sans the \n--save\n flag lets you try packages locally without making a mess of your dappfile in the process. \n\n\nTo remove packages, use \nuninstall\n:\n\n\ndapple uninstall \nsomepackage\n --save\n\n\n\nPackage publishing\n\n\nPublishing a package is as simple as:\n\n\ndapple publish\n\n\n\nYou must, however, have a copy of \nIPFS\n running and your \n.dapplerc\n pointed at it to publish anything. By default, Dapple connects to a public read-only gateway maintained by the IPFS developers to allow package installation without a local copy of IPFS. Publishing cannot be done through such a gateway.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/quickstart/#quickstart", 
            "text": "", 
            "title": "Quickstart"
        }, 
        {
            "location": "/quickstart/#a-note-before-starting", 
            "text": "Throughout this documentation, I use words in   to denote where you should fill in values of your own choosing. I have endeavored to make the angle-bracketed phrases self-explanatory and consistent. For example, I use   to denote the name you choose for your package. Anywhere you see  , you should be able to fill in the same value you chose initially and do alright.", 
            "title": "A note before starting"
        }, 
        {
            "location": "/quickstart/#installation", 
            "text": "On the command line:  git clone https://github.com/MakerDAO/dapple\ncd dapple\npython setup.py install", 
            "title": "Installation"
        }, 
        {
            "location": "/quickstart/#package-creation", 
            "text": "On the command line:  mkdir  mypackage \ncd  mypackage \ndapple init  Dapple packages are defined by the presence of a  .dapple  directory containing a  dappfile  YAML file.  dapple init  creates this structure for you. Edit  .dapple/dappfile  in your   directory to, at minimum, list your package's name and version. By default, the  core  package is included as a dependency of all new packages. The  core  package contains the contracts that Dapple relies on to run tests on your smart contract package.", 
            "title": "Package creation"
        }, 
        {
            "location": "/quickstart/#package-installation", 
            "text": "From within your package's root directory:  dapple install  somepackage  --save  The  --save  flag tells Dapple that it should add the package to your dependencies map in your dappfile. Without this flag, Dapple would install the package without adding it to your dappfile. Generally, Dapple tries to make it obvious when it's about to change your dappfile. Running  install  sans the  --save  flag lets you try packages locally without making a mess of your dappfile in the process.   To remove packages, use  uninstall :  dapple uninstall  somepackage  --save", 
            "title": "Package installation"
        }, 
        {
            "location": "/quickstart/#package-publishing", 
            "text": "Publishing a package is as simple as:  dapple publish  You must, however, have a copy of  IPFS  running and your  .dapplerc  pointed at it to publish anything. By default, Dapple connects to a public read-only gateway maintained by the IPFS developers to allow package installation without a local copy of IPFS. Publishing cannot be done through such a gateway.", 
            "title": "Package publishing"
        }, 
        {
            "location": "/constants/", 
            "text": "Constants\n\n\nConstants are addresses defined via the \ncontexts\n keys in a package's \ndappfile\n. Each context refers to a different chain environment and follows this structure:\n\n\n\n\ncontexts\n\n\ndefault\n - This is the default context when no context is specified.\n\n\nsome constant name\n - Keys and values defined at this level are constant names and values.\n\n\n\n\n\n\nsome context\n - You can define any other context name you like. Follows the same structure as \ndefault\n.\n\n\n\n\n\n\n\n\nTo refer to constants in your smart contract code, use \nCONSTANT(\nyour constant name\n)\n. For example, given a dappfile containing this:\n\n\ncontexts:\n    default:\n        namereg: '0x01010101'\n\n\n\nYou could do this:\n\n\nNameReg myNameReg = NameReg(CONSTANT(namereg));\n\n\n\nConstants in dependencies\n\n\nYou can also refer to any constants defined in your dependencies via dot notation. So if the \ncore\n package had a \nnamereg\n constant, you could use it like this:\n\n\nNameReg officialNameReg = NameReg(CONSTANT(core.namereg))\n\n\n\nYou can use the same dot notation, also called the \npackage path\n, to override constants in your dependencies as well:\n\n\ncontexts:\n    default:\n        'core.namereg': '0x010101'\n\n\n\nSuch overrides only affect your package's copies of the dependencies referred to, of course.\n\n\nUndefined constants\n\n\nAny undefined constants referred to will end up in the hex code output, allowing Dapple to replace them on the fly when running your deploy script. If your dappfile didn't contain the constant definition above, you might end up seeing something like this:\n\n\n$ dapple build\n{'Example': {'bin': '606060405269__CONSTANT(namereg)__600060006101000a81548173ffffffffffffffffffffffffffffffffffffffff02191690830217905550600a8060456000396000f360606040526008565b00', 'abi': '[]', 'interface': 'contract Example{}'}}", 
            "title": "Constants"
        }, 
        {
            "location": "/constants/#constants", 
            "text": "Constants are addresses defined via the  contexts  keys in a package's  dappfile . Each context refers to a different chain environment and follows this structure:   contexts  default  - This is the default context when no context is specified.  some constant name  - Keys and values defined at this level are constant names and values.    some context  - You can define any other context name you like. Follows the same structure as  default .     To refer to constants in your smart contract code, use  CONSTANT( your constant name ) . For example, given a dappfile containing this:  contexts:\n    default:\n        namereg: '0x01010101'  You could do this:  NameReg myNameReg = NameReg(CONSTANT(namereg));", 
            "title": "Constants"
        }, 
        {
            "location": "/constants/#constants-in-dependencies", 
            "text": "You can also refer to any constants defined in your dependencies via dot notation. So if the  core  package had a  namereg  constant, you could use it like this:  NameReg officialNameReg = NameReg(CONSTANT(core.namereg))  You can use the same dot notation, also called the  package path , to override constants in your dependencies as well:  contexts:\n    default:\n        'core.namereg': '0x010101'  Such overrides only affect your package's copies of the dependencies referred to, of course.", 
            "title": "Constants in dependencies"
        }, 
        {
            "location": "/constants/#undefined-constants", 
            "text": "Any undefined constants referred to will end up in the hex code output, allowing Dapple to replace them on the fly when running your deploy script. If your dappfile didn't contain the constant definition above, you might end up seeing something like this:  $ dapple build\n{'Example': {'bin': '606060405269__CONSTANT(namereg)__600060006101000a81548173ffffffffffffffffffffffffffffffffffffffff02191690830217905550600a8060456000396000f360606040526008565b00', 'abi': '[]', 'interface': 'contract Example{}'}}", 
            "title": "Undefined constants"
        }, 
        {
            "location": "/dappfile/", 
            "text": "dappfile\n\n\nYour pacakge's dappfile contains all the settings necessary to set up dependencies and compile your package's code properly. It is a YAML file with the following structure:\n\n\n\n\n\n\nname\n: The name of the dapple package. (Required)\n\n\n\n\n\n\nversion\n: The version of the dapple package. (Required)\n\n\n\n\n\n\nsource_dir\n: By default, Dapple will process all source files in the project's root directory and its descendants. It will also interpret imports relative to the project's root directory during the build process. This setting overrides this behavior and allows you to specify a subfolder of the project to use instead.\n\n\n\n\n\n\nignore\n: A list of filenames to ignore. \nGlobbing\n is supported.\n\n\n\n\n\n\npreprocessor_vars\n: Variables to pass in for your preprocessor or templating engine to use in its rendering context. Dapple uses \ncogapp\n by default.\n\n\n\n\n\n\ncontexts\n: A mapping of environment names to constants and their values. Constants may be inserted into smart contract source code at any point via \nCONSTANT:\"some_constant\"\n.\n\n\n\n\n\n\ndependencies\n: A mapping of the names of dapple packages this package depends on to the specific versions of those packages required, or to the specific location to load the package from. A value of \"latest\" signifies that the latest version should be used.\n\n\n\n\n\n\nYou may use dot notation to collapse nested mappings. In other words, this:\n\n\ncontexts:\n    prod:\n        NAME_REG: \"0x...\"\n\n\n\nCan be shortened to this:\n\n\ncontexts.prod.NAME_REG: \"0x...\"", 
            "title": "dappfile"
        }, 
        {
            "location": "/dappfile/#dappfile", 
            "text": "Your pacakge's dappfile contains all the settings necessary to set up dependencies and compile your package's code properly. It is a YAML file with the following structure:    name : The name of the dapple package. (Required)    version : The version of the dapple package. (Required)    source_dir : By default, Dapple will process all source files in the project's root directory and its descendants. It will also interpret imports relative to the project's root directory during the build process. This setting overrides this behavior and allows you to specify a subfolder of the project to use instead.    ignore : A list of filenames to ignore.  Globbing  is supported.    preprocessor_vars : Variables to pass in for your preprocessor or templating engine to use in its rendering context. Dapple uses  cogapp  by default.    contexts : A mapping of environment names to constants and their values. Constants may be inserted into smart contract source code at any point via  CONSTANT:\"some_constant\" .    dependencies : A mapping of the names of dapple packages this package depends on to the specific versions of those packages required, or to the specific location to load the package from. A value of \"latest\" signifies that the latest version should be used.    You may use dot notation to collapse nested mappings. In other words, this:  contexts:\n    prod:\n        NAME_REG: \"0x...\"  Can be shortened to this:  contexts.prod.NAME_REG: \"0x...\"", 
            "title": "dappfile"
        }, 
        {
            "location": "/dapplerc/", 
            "text": ".dapplerc\n\n\nYour .dapplerc file contains Dapple's global settings. It can be found in your home directory.(The \n~\n command line path for OS X and Linux users.)\n\n\n.dapplerc is a \nYAML\n file with the following structure:\n\n\n\n\nipfs\n - Settings related to connecting to IPFS.\n\n\nhost\n - The hostname for the IPFS node. Can start with 'http://' or 'https://'.\n\n\nport\n - This port on the IPFS node to connect to. Usually \n80\n or \n8080\n for read-only gateways and \n5001\n for full nodes.", 
            "title": ".dapplerc"
        }, 
        {
            "location": "/dapplerc/#dapplerc", 
            "text": "Your .dapplerc file contains Dapple's global settings. It can be found in your home directory.(The  ~  command line path for OS X and Linux users.)  .dapplerc is a  YAML  file with the following structure:   ipfs  - Settings related to connecting to IPFS.  host  - The hostname for the IPFS node. Can start with 'http://' or 'https://'.  port  - This port on the IPFS node to connect to. Usually  80  or  8080  for read-only gateways and  5001  for full nodes.", 
            "title": ".dapplerc"
        }, 
        {
            "location": "/plugins/", 
            "text": "Plugins\n\n\nEvery aspect of Dapple's core behavior is defined in terms of overrideable plugins. Plugin discovery is achieved via the \nplugins\n file in your package's \n.dapple\n directory. The \nplugins\n file is just a newline-delimited list of Python modules that Dapple will import each time it runs, before attempting to parse any arguments or commands. To write plugin, just write a Python module that does all its setup in its \n__init__.py\n file.\n\n\nWe have provided a few hooks into Dapple to facilitate plugin development:\n\n\n\n\ndapple.cli\n - Contains a \ncli\n object, which is an instance of the \nGroup\n class, and a \nclick\n variable, which is a reference to the \nClick\n module Dapple uses.\n\n\ndapple.plugins\n - Programmatic access to different functions defined by plugins.\n\n\n\n\nCreating subcommands\n\n\nThe \ncli\n object in \ndapple.cli\n allows you to register new Dapple commands. For example, to create a command called \nhello\n that just prints out \nHello World!\n:\n\n\nfrom dapple.cli import cli\n\n@cli.command()\ndef hello():\n    print \"Hello World!\"\n\n\n\nFor more information, check out Click's documentation on the \nGroup\n class. The \ncli\n object is nothing more than an instance of that class.\n\n\ndapple.plugins\n\n\ndapple.plugins.registry\n is a module-level instance of the \nPluginRegistry\n class. This is hte registry plugins are registered with by default. Provides \nload\n and \nregister\n functions, which the module-level \nregister\n decorator and \nload\n function wrap.\n\n\ndapple.plugins.load\n is a function that takes a plugin function name and returns the function registered under that name.\n\n\ndapple.plugins.register\n is a decorator that takes a name to register the decorated function under. By convention, the name should be prefixed with the plugin's name, like so:\n\n\n@dapple.plugins.register('core.dappfile')\nfunction load_dappfile(package_path='', env=None):\n    ... # plugin code\n\n\n\nAny plugin loaded afterward can then get a reference to the function through \ndapple.plugins.load\n:\n\n\nload_dappfile = dapple.plugins.load('core.dappfile')\ndappfile = load_dappfile()\n\n\n\nYou may also override plugin functions by registering new functions by the same name after the original function has been registered:\n\n\n@dapple.plugins.register('core.dappfile')\nfunction my_dappfile(package_path='', env=None):\n    # In case you want to use the original function somewhere.\n    original_func = dapple.plugins.load('core.dappfile')\n    dapple.plugins.registry.register('core.old_dappfile', original_func)\n    ... # your altered plugin code", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#plugins", 
            "text": "Every aspect of Dapple's core behavior is defined in terms of overrideable plugins. Plugin discovery is achieved via the  plugins  file in your package's  .dapple  directory. The  plugins  file is just a newline-delimited list of Python modules that Dapple will import each time it runs, before attempting to parse any arguments or commands. To write plugin, just write a Python module that does all its setup in its  __init__.py  file.  We have provided a few hooks into Dapple to facilitate plugin development:   dapple.cli  - Contains a  cli  object, which is an instance of the  Group  class, and a  click  variable, which is a reference to the  Click  module Dapple uses.  dapple.plugins  - Programmatic access to different functions defined by plugins.", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#creating-subcommands", 
            "text": "The  cli  object in  dapple.cli  allows you to register new Dapple commands. For example, to create a command called  hello  that just prints out  Hello World! :  from dapple.cli import cli\n\n@cli.command()\ndef hello():\n    print \"Hello World!\"  For more information, check out Click's documentation on the  Group  class. The  cli  object is nothing more than an instance of that class.", 
            "title": "Creating subcommands"
        }, 
        {
            "location": "/plugins/#dappleplugins", 
            "text": "dapple.plugins.registry  is a module-level instance of the  PluginRegistry  class. This is hte registry plugins are registered with by default. Provides  load  and  register  functions, which the module-level  register  decorator and  load  function wrap.  dapple.plugins.load  is a function that takes a plugin function name and returns the function registered under that name.  dapple.plugins.register  is a decorator that takes a name to register the decorated function under. By convention, the name should be prefixed with the plugin's name, like so:  @dapple.plugins.register('core.dappfile')\nfunction load_dappfile(package_path='', env=None):\n    ... # plugin code  Any plugin loaded afterward can then get a reference to the function through  dapple.plugins.load :  load_dappfile = dapple.plugins.load('core.dappfile')\ndappfile = load_dappfile()  You may also override plugin functions by registering new functions by the same name after the original function has been registered:  @dapple.plugins.register('core.dappfile')\nfunction my_dappfile(package_path='', env=None):\n    # In case you want to use the original function somewhere.\n    original_func = dapple.plugins.load('core.dappfile')\n    dapple.plugins.registry.register('core.old_dappfile', original_func)\n    ... # your altered plugin code", 
            "title": "dapple.plugins"
        }, 
        {
            "location": "/core/", 
            "text": "Core Package\n\n\nBy default, Dapple adds a dependency on a package called \ncore\n to all new Dapple packages. This package provides simple contracts that can be extended to take advantage of some of Dapple's features.\n\n\ncore/debug.sol\n\n\ncontract Debug\n\n\nThis contract provides events that produce logging output during testing. (I.e., when running \ndapple test\n.)\n\n\nlogs(bytes value)\n\n\nLogs a \nstring\n or a \nbytes\n value (which is then interpreted as a string).\n\n\nlog_bool(bool value)\n\n\nLogs a boolean value.\n\n\nlog_named_bool(bytes32 extra_data, bool value)\n\n\nLogs a boolean value along with a 32-byte string.\n\n\nlog_uint(uint value)\n\n\nLogs an unsigned integer value.\n\n\nlog_named_uint(bytes32 extra_data, uint value)\n\n\nLogs an unsigned integer value along with a 32-byte string.\n\n\nlog_int(int value)\n\n\nLogs an integer value.\n\n\nlog_named_int(bytes32 extra_data, int value)\n\n\nLogs an integer value along with a 32-byte string.\n\n\nlog_address(address value)\n\n\nLogs an address.\n\n\nlog_named_address(bytes32 extra_data, address value)\n\n\nLogs an address value along with a 32-byte string.\n\n\nlog_bytes(bytes value)\n\n\nLogs a \nbytes\n value.\n\n\nlog_named_bytes(bytes32 extra_data, bytes value)\n\n\nLogs a \nbytes\n value along with a 32-byte string.\n\n\nlog_bytes[1..32](bytes[1..32] value)\n\n\nThis entry is for the 32 logging functions numbered consecutively from \nlog_bytes1\n to \nlog_bytes32\n. Each logs a value consisting of the specified number of bytes.\n\n\nlog_named_bytes[1..32](bytes32 extra_data, bytes[1..32] value)\n\n\nThis entry is for the 32 logging functions numbered consecutively from \nlog_named_bytes1\n to \nlog_named_bytes32\n. Each logs a value consisting of the specified number of bytes, along with a 32-byte string.\n\n\nString formatting\n\n\nDapple supports combining the output of multiple log events via \n%s\n. For example, this code:\n\n\nlogs(\n%s + %s = %s\n);\nlog_uint(2);\nlog_uint(2);\nlog_uint(4);\n\n\n\n\nproduces this output:\n\n\n2 + 2 = 4\n\n\n\n\ncore/test.sol\n\n\ncontract Test is Debug\n\n\nTest contracts must inherit from this contract. It provides some basic assertion-related functions in addition to the events defined in its \nDebug\n parent type.\n\n\nfail()\n\n\nImmediately fail the test.\n\n\nassertTrue(bool value[, bytes32 error_message])\n\n\nFails the test if \nvalue\n is \nfalse\n. If \nerror_message\n is provided, includes it in the logging output upon failure. \n\n\nassertFalse(bool value[, bytes32 error_message])\n\n\nFails the test if \nvalue\n is \ntrue\n. If \nerror_message\n is provided, includes it in the logging output upon failure. \n\n\nassertEq0(bytes value_1, bytes value_2, bytes32 error_message)\n\n\nFails the test if the two \nbytes\n values are not equal. (Has to be equal in both length and value to pass.)\n\n\nassertEq[1..32](bytes[1..32] value_1, bytes[1..32] value_2[, bytes32 error_message])\n\n\nThis entry is for the 32 functions defined for comparing specific byte-length types, numbered consecutively from \nassertEq1\n to \nassertEq32\n. Fails the test if the two values are not equal and optionally takes an error message to show upon failure.\n\n\nassertEq(uint value_1, uint value_2[, bytes32 error_message])\n\n\nFails the test if the two unsigned integers are not equal. Optionally takes a bytes-32 error message to log if the test fails.\n\n\nassertEq(int value_1, int value_2[, bytes32 error_message])\n\n\nFails the test if the two integers are not equal. Optionally takes a bytes-32 error message to log if the test fails.\n\n\nassertEq(bool value_1, bool value_2[, bytes32 error_message])\n\n\nFails the test if the two booleans are not equal. Optionally takes a bytes-32 error message to log if the test fails.\n\n\nassertEq(address value_1, address value_2[, bytes32 error_message])\n\n\nFails the test if the two addresses are not equal. Optionally takes a bytes-32 error message to log if the test fails.", 
            "title": "Core Package"
        }, 
        {
            "location": "/core/#core-package", 
            "text": "By default, Dapple adds a dependency on a package called  core  to all new Dapple packages. This package provides simple contracts that can be extended to take advantage of some of Dapple's features.", 
            "title": "Core Package"
        }, 
        {
            "location": "/core/#coredebugsol", 
            "text": "contract Debug  This contract provides events that produce logging output during testing. (I.e., when running  dapple test .)  logs(bytes value)  Logs a  string  or a  bytes  value (which is then interpreted as a string).  log_bool(bool value)  Logs a boolean value.  log_named_bool(bytes32 extra_data, bool value)  Logs a boolean value along with a 32-byte string.  log_uint(uint value)  Logs an unsigned integer value.  log_named_uint(bytes32 extra_data, uint value)  Logs an unsigned integer value along with a 32-byte string.  log_int(int value)  Logs an integer value.  log_named_int(bytes32 extra_data, int value)  Logs an integer value along with a 32-byte string.  log_address(address value)  Logs an address.  log_named_address(bytes32 extra_data, address value)  Logs an address value along with a 32-byte string.  log_bytes(bytes value)  Logs a  bytes  value.  log_named_bytes(bytes32 extra_data, bytes value)  Logs a  bytes  value along with a 32-byte string.  log_bytes[1..32](bytes[1..32] value)  This entry is for the 32 logging functions numbered consecutively from  log_bytes1  to  log_bytes32 . Each logs a value consisting of the specified number of bytes.  log_named_bytes[1..32](bytes32 extra_data, bytes[1..32] value)  This entry is for the 32 logging functions numbered consecutively from  log_named_bytes1  to  log_named_bytes32 . Each logs a value consisting of the specified number of bytes, along with a 32-byte string.  String formatting  Dapple supports combining the output of multiple log events via  %s . For example, this code:  logs( %s + %s = %s );\nlog_uint(2);\nlog_uint(2);\nlog_uint(4);  produces this output:  2 + 2 = 4", 
            "title": "core/debug.sol"
        }, 
        {
            "location": "/core/#coretestsol", 
            "text": "contract Test is Debug  Test contracts must inherit from this contract. It provides some basic assertion-related functions in addition to the events defined in its  Debug  parent type.  fail()  Immediately fail the test.  assertTrue(bool value[, bytes32 error_message])  Fails the test if  value  is  false . If  error_message  is provided, includes it in the logging output upon failure.   assertFalse(bool value[, bytes32 error_message])  Fails the test if  value  is  true . If  error_message  is provided, includes it in the logging output upon failure.   assertEq0(bytes value_1, bytes value_2, bytes32 error_message)  Fails the test if the two  bytes  values are not equal. (Has to be equal in both length and value to pass.)  assertEq[1..32](bytes[1..32] value_1, bytes[1..32] value_2[, bytes32 error_message])  This entry is for the 32 functions defined for comparing specific byte-length types, numbered consecutively from  assertEq1  to  assertEq32 . Fails the test if the two values are not equal and optionally takes an error message to show upon failure.  assertEq(uint value_1, uint value_2[, bytes32 error_message])  Fails the test if the two unsigned integers are not equal. Optionally takes a bytes-32 error message to log if the test fails.  assertEq(int value_1, int value_2[, bytes32 error_message])  Fails the test if the two integers are not equal. Optionally takes a bytes-32 error message to log if the test fails.  assertEq(bool value_1, bool value_2[, bytes32 error_message])  Fails the test if the two booleans are not equal. Optionally takes a bytes-32 error message to log if the test fails.  assertEq(address value_1, address value_2[, bytes32 error_message])  Fails the test if the two addresses are not equal. Optionally takes a bytes-32 error message to log if the test fails.", 
            "title": "core/test.sol"
        }, 
        {
            "location": "/glossary/", 
            "text": "Glossary\n\n\nThere's some internal jargon that we use which you might find floating around in our documentation from time to time. Here's what most of it means:\n\n\nChain fork:\n Forking public chains off into private chains is a core part of testing with Dapple. This allows you to test against the state of the blockchain your package will eventually be deployed to at any given height, giving you a 100% reproducible testing environment that can refer to the real addresses of real contracts. This also means your tests can run in parallel without inadvertantly changing the shared state each depends on and causing random failures.\n\n\nPackage path:\n The location of a given package in the dependency hierarchy relative to your root package. Since each dependency in your package may rely on different versions and variations of the same package, each one keeps its own copy of its dependencies within its own directory. The path to the \ncore\n package your package relies on is simply \ncore\n, while the path to the \ncore\n package \n relies on is \nsome other dependency\n.core\n.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary", 
            "text": "There's some internal jargon that we use which you might find floating around in our documentation from time to time. Here's what most of it means:  Chain fork:  Forking public chains off into private chains is a core part of testing with Dapple. This allows you to test against the state of the blockchain your package will eventually be deployed to at any given height, giving you a 100% reproducible testing environment that can refer to the real addresses of real contracts. This also means your tests can run in parallel without inadvertantly changing the shared state each depends on and causing random failures.  Package path:  The location of a given package in the dependency hierarchy relative to your root package. Since each dependency in your package may rely on different versions and variations of the same package, each one keeps its own copy of its dependencies within its own directory. The path to the  core  package your package relies on is simply  core , while the path to the  core  package   relies on is  some other dependency .core .", 
            "title": "Glossary"
        }
    ]
}